from google.adk.agents.llm_agent import LlmAgent
from google.adk.tools.mcp_tool.mcp_toolset import MCPToolset, StdioConnectionParams, StdioServerParameters

import re
import sys


import requests
import logging
import asyncio
import httpx
from uuid import uuid4
from google.adk.tools import FunctionTool
from google.adk.tools.tool_context import ToolContext
from google.adk.tools.base_tool import BaseTool
from typing import Any, AsyncIterable, Optional, Dict, List
import os

SERVICE_URL=os.environ.get('SERVICE_URL')
async def add_event_to_ui_async(caller, called, event, data):
    url = f'{SERVICE_URL}/event'
    payload = {
        "caller": caller,
        "called": called,
        "event": event,
        "data": data
    }
    async with httpx.AsyncClient() as client:
        try:
            await client.post(url, json=payload)
        except Exception as e:
            print(f"Error posting event to UI: {e}")

def add_event_to_ui(caller, called, event, data):
    #"Tool Call"
    # "Remote Agent Call"
    try:
        loop = asyncio.get_event_loop()
        if loop.is_running():
            asyncio.create_task(add_event_to_ui_async(caller, called, event, data))
        else:
            loop.run_until_complete(add_event_to_ui_async(caller, called, event, data))
    except RuntimeError:
        print("IT FAILED HERE")
        asyncio.run(add_event_to_ui_async(caller, called, event, data))

async def request_async_offload(url, payload):
     response = None
     async with httpx.AsyncClient() as client:
        try:
            response = await client.post(url, json=payload)
            return response
        except Exception as e:
            print(f"Error posting event to UI: {e}")
            return "error"

def simple_before_tool_modifier(
    tool: BaseTool, args: Dict[str, Any], tool_context: ToolContext
) -> Optional[Dict]:
    """Inspects/modifies tool args or skips the tool call."""
    agent_name = tool_context.agent_name
    tool_name = tool.name
    caller = "Malware Analysis Agent"
    called = ""
    event =  ""
    data = ""
    parts_text = ""
    if tool_name == "transfer_to_agent":
        called = args["agent_name"]
        event = "Remote Agent Call"
        print(tool_context._invocation_context.session.events[-1])
        parts_text = [part.text for part in tool_context._invocation_context.session.events[-1].content.parts if hasattr(part, 'text') and part.text]
        if parts_text:
            parts_text = ' BREAK '.join(parts_text)
        else: 
            parts_text = "nothing"
    else: 
        called = tool_name
        event = "Tool Call"
        parts_text = args
    add_event_to_ui(caller, called, event, parts_text)
    print(f"[Callback] Before tool call for tool '{tool_name}' in agent '{agent_name}'")
    print(f"[Callback] Original args: {args}")
    
    print(f"[Callback] Tool context: {parts_text}.")
    print("[Callback] Proceeding with original or previously modified args.")
    return None



def get_disassembled_file(tool_context: ToolContext, url: Optional[str] = None) -> str:
    """
    Gets disassembled file content, downloading it only if not already cached.

    This tool first checks an in-memory cache (`tool_context.state`) for the
    disassembled file. If found, it returns the cached content. If not, it
    requires a URL to download the file, cache it, and then return it. This
    ensures the file is only downloaded once per session.

    Args:
        url (Optional[str]): The secure URL pointing to the disassembled file.
            This is only required on the first call. On subsequent calls, this
            can be omitted to retrieve the cached version.

    Returns:
        str | None: The content of the file as a string. Returns None if a
                    network error occurs on the initial download or if the URL
                    is omitted on the first call.
    """
    disassembled_file = tool_context.state.get("disassembled_file")
    if disassembled_file:
        return disassembled_file

    if not url:
        return "Error: URL is required for the first call when the file is not cached."

    try:
        response = requests.get(url, timeout=15)
        # Will raise an HTTPError if the HTTP request returned an unsuccessful status code
        response.raise_for_status()
        
        file_content = response.text
        tool_context.state["disassembled_file"] = file_content
        return file_content
    except requests.exceptions.RequestException as e:
        # In a real system, this error would be logged for the operator.
        # For the agent's context, returning None is sufficient.
        print(f"An error occurred while downloading the file: {e}")
        return "something went wrong while downloading the file"


def generate_malware_report(
    file_assembly: str,
    verdict: str,
    primary_capability: str,
    overall_risk: str,
    behavioral_analysis: Dict[str, str],
    iocs: List[Dict[str, str]],
    conclusion: str,
    tool_context: ToolContext,
    malware_family: Optional[str] = "Unknown",
) -> str:
    """
    Generates a structured Markdown report for malware analysis findings.

    This tool takes all the synthesized findings from a malware analysis agent
    and formats them into a standardized, human-readable report. The agent
    should call this tool only after completing all analysis and enrichment steps.

    Args:
        file_assembly (str): The full disassembled code of the analyzed file.
        verdict (str): The final verdict on the file (e.g., 'MALICIOUS',
            'SUSPICIOUS', 'BENIGN').
        primary_capability (str): The primary function of the malware (e.g.,
            'Information Stealer', 'Downloader').
        overall_risk (str): The assessed risk level (e.g., 'CRITICAL', 'HIGH',
            'MEDIUM').
        behavioral_analysis (Dict[str, str]): A dictionary detailing the malware's
            capabilities. Keys should be categories like 'Network Communication',
            'Persistence', etc.
        iocs (List[Dict[str, str]]): A list of dictionaries, where each
            dictionary represents an Indicator of Compromise (IOC) and must
            contain 'Type', 'Indicator', and 'Threat Intel Summary' keys.
        conclusion (str): The final summary and recommendation from the agent.
        malware_family (Optional[str], optional): The identified malware family,
            if known. Defaults to "Unknown".

    Returns:
        str: A fully formatted Markdown string containing the complete analysis
             report.
    """
    report = f"""# Malware Analysis Report

**File Assembly:**
```assembly
{file_assembly}
```

---

### 1. Executive Summary

* **Verdict:** {verdict}
* **Malware Family:** {malware_family}
* **Primary Capability:** {primary_capability}
* **Overall Risk:** {overall_risk}

---

### 2. Behavioral Analysis

A static analysis of the binary indicates the following capabilities:
"""
    for category, description in behavioral_analysis.items():
        report += f"\n* **{category}:** {description}"

    report += "\n\n---\n\n### 3. Indicators of Compromise (IOCs)\n\nThe following IOCs were extracted from the binary and correlated with our threat intelligence platform.\n\n"
    report += "| Type   | Indicator                 | Threat Intel Summary                                      |\n"
    report += "| :----- | :------------------------ | :-------------------------------------------------------- |\n"
    for ioc in iocs:
        report += f"| **{ioc.get('Type', 'N/A')}** | `{ioc.get('Indicator', 'N/A')}`           | {ioc.get('Threat Intel Summary', 'N/A')} |\n"

    report += f"""
---

### 4. Conclusion and Summary

{conclusion}
"""


def decode_from_asm_listing(
    listing_path: str,
    target_address: str,
    length: int,
    key: int
) -> Optional[str]:
    """Extracts and decodes a single-byte XOR-encoded string from a disassembly listing.

    This function is designed for cybersecurity and reverse engineering tasks,
    particularly for extracting configuration data (like C2 IPs or domains)
    from static malware disassembly. It reads a text file containing an
    assembly listing, searches for a specific virtual address, extracts a
    sequence of hexadecimal bytes from that line, and decodes them using a
    provided single-byte XOR key.

    The function is robust to common variations in disassembly output formats,
    such as the presence of section prefixes (e.g., '.data:00401000') and
    different byte representations (e.g., 'db 0C7h' vs. 'C7').

    Args:
        listing_path (str): The full path to the input text file containing
            the assembly listing (e.g., '/path/to/disassembly.txt').
        target_address (str): The target virtual address to locate within the
            listing. The address should be provided as a hexadecimal string,
            with or without a '0x' prefix (e.g., '0x402010' or '402010').
        length (int): The exact number of encoded bytes to read and decode
            starting from the target address.
        key (int): The single integer byte (0-255) to use for the XOR
            decryption operation.

    Returns:
        Optional[str]: 
        - On success: A UTF-8 decoded string, with any trailing null
          bytes ('\\x00') stripped from the end.
        - On failure: `None`. Failure occurs if the file cannot be found,
          the target address is not located in the file, or not enough
          bytes can be extracted from the corresponding line. Diagnostic
          messages are printed to stderr in these cases.

    Example:
        Given a file `disassembly.txt` with the following content:
        '''
        .text:00401560 mov     eax, offset aMalwareString ; "MalwareString"
        ...
        .data:00402010 C7 D6 D6 C3 C4 2E C3 D3 C4 2E C2 C3 C5 ; Encoded IP bytes
        .data:00402020 C6 C7 C2 C3 00 00 00 00 ; Encoded Port bytes
        '''
        
        >>> ip = decode_from_asm_listing(
        ...     listing_path='disassembly.txt',
        ...     target_address='0x402010',
        ...     length=13,
        ...     key=0xaa
        ... )
        >>> print(ip)
        193.192.84.195

        >>> port = decode_from_asm_listing(
        ...     listing_path='disassembly.txt',
        ...     target_address='0x402020',
        ...     length=8,
        ...     key=0xaa
        ... )
        >>> print(port)
        8949
    """
    # 1. Normalize input for robust matching.
    # The address is made lowercase and the '0x' prefix is removed.
    target_addr_norm = target_address.lower().replace("0x", "")
    with open('0.txt', 'w') as f:
        f.write("target_addr_norm: "+target_addr_norm+"  key: "+str(key) + "   length:" + str(length)+'\n')
    try:
        # 2. Open and read the assembly listing file.
        # TODO: Change:
        listing_path = '/home/admin_/a2a-sec/agents/remote_agents/malware_analysis_agent/assembly_replacement.txt'
        with open(listing_path, 'r') as f:
            junk = ""
            for line in f:
                line_norm = line.lower().strip()

                # 3. Search for the line corresponding to the target address.
                # This handles formats like "00402010..." and ".data:00402010...".
                # It splits the line by ':' and checks if the last part starts
                # with the normalized address.
                if any(x.strip().startswith(target_addr_norm) for x in line_norm.split(':')[:-1]):
                    # 4. Extract all 2-character hex strings from the line.
                    # This regex finds all whole words that consist of exactly two hex chars.
                    hex_values = re.findall(r'\b[0-9a-fA-F]{2}\b', line)
                    with open('1.txt', 'w') as f:
                        f.write(str(hex_values)+'\n')
                    if len(hex_values) < length:
                        # Found the address but the line doesn't contain enough bytes.
                        # Continue searching in case the address appears again.
                        continue

                    # 5. Convert hex strings to integers and perform XOR decryption.
                    # It takes only the required number of bytes specified by `length`.
                    encoded_ints = [int(h, 16) for h in hex_values[:length]]
                    decoded_bytes = bytes([i ^ key for i in encoded_ints])
                    with open('2.txt', 'w') as f:
                        f.write(decoded_bytes.decode('utf-8', errors='ignore').strip('\x00')+'\n')
                    # 6. Decode byte sequence to string and clean up.
                    # Result is returned after removing common null padding.
                    return decoded_bytes.decode('utf-8', errors='ignore').strip('\x00')
                else: 
                    newl = line_norm.split(':')[-1].strip() + "\n"
                    junk  += line_norm.split(':')[-1].strip() + "\n"
                
        # If the loop completes without finding the address, it's a failure.
        print(f"[-] AGENT_LOG: Address {target_address} not found in '{listing_path}'.", file=sys.stderr)
        # with open('3.txt', 'w') as f:
        #     f.write(junk)
        return None

    except FileNotFoundError:
        print(f"[!] AGENT_LOG: File not found at '{listing_path}'.", file=sys.stderr)
        return None
    except Exception as e:
        print(f"[!] AGENT_LOG: An unexpected error occurred: {e}", file=sys.stderr)
        return None

root_agent = LlmAgent(
            model="gemini-2.5-pro",
            name="malware_analysis_agent",
            description="An agent for Malware Analysis operations.",
            #agent_card=(f'http://localhost:10003/a2a/chat_agent{AGENT_CARD_WELL_KNOWN_PATH}'),
            instruction="""
You are a world-class **Senior Malware Reverse Engineer and Threat Analyst**. Your expertise lies in static analysis of suspicious binaries, disassembling code, identifying malicious behavior patterns, and extracting actionable threat intelligence. Your analysis is methodical, evidence-based, and precise. You operate with the assumption that any file could be part of a sophisticated attack, and your goal is to uncover its true purpose and capabilities.
Do not try and run the file under any circumstances.

**Objective**
 
Your primary objective is to perform a static analysis of a provided disassembled file. You will analyze its code for malicious behavior, extract Indicators of Compromise (IOCs), enrich these IOCs using a threat intelligence API, and synthesize all findings into a comprehensive security report.

---

 
**Workflow & Execution Plan**

You must follow this step-by-step workflow. Before providing the final report, you must outline your internal thought process. ALWAYS be cautious, alert, and pessimistic.

**Step 1: Initial Validation & File Acquisition**
1.  **Validate Input:** The orchestrator might provide a resource link (URL) to the disassembled file if it does not use get_disassembled_file to check if you already have access to the file. Your first action is to verify its presence. If you've called get_disassembled_file and there is no file and no url was provided: **Action:** Report back immediately that the resource link is missing.
2.  **Acquire Content:** Call the `get_disassembled_file` tool, passing the URL (if provided) by the orchestrator. This will download and cache the file's content or return the already cached file.
    * **On Failure:** If the tool returns `None`, the download failed. **Action:** Report this failure to the orchestrator.
3.  **Think:** Formulate your plan. State your intention: "I have acquired the disassembled code. I will now scan it for suspicious API calls and strings to understand its behavior and extract potential IOCs. Next, I will enrich these IOCs using the Threat Intelligence API. Finally, I will compile all findings into a structured report using the report generation tool."
 
**Step 2: Static Code Analysis & Behavioral Assessment on The Assembly Code**
1.  **Analyze Imports:** Examine the list of imported functions from system libraries (e.g., 'kernel32.dll', 'ws2_32.dll'). Look for functions commonly used by malware for:
    * **Networking:** 'socket', 'connect', 'send', 'URLDownloadToFile', 'InternetOpen'.
    * **File System:** 'CreateFile', 'WriteFile', 'DeleteFile', 'MoveFile'.
    * **Process Manipulation:** 'CreateRemoteThread', 'WriteProcessMemory', 'CreateProcess'.
    * **Persistence:** 'RegCreateKey', 'RegSetValue', 'SchTasksCreate'.
    * **Defense Evasion:** 'IsDebuggerPresent', 'GetTickCount'.
2.  **Scan for Suspicious Patterns:** Use the 'CodeInterpreter' to parse the disassembly output. Search for code blocks corresponding to the imported functions above. Investigate how they are used.
3.  **String Extraction:** Scan the disassembly output and the raw binary for hardcoded strings. Use regex to specifically search for:
    * IP Addresses (IPv4 & IPv6)
    * URLs and Domain Names
    * File paths (e.g., 'C:%UsersÂ­min%AppData%...')
    * Registry keys (e.g., 'HKLM%%Software%%Microsoft%%Windows%%CurrentVersion%%Run')
    * Mutex names, user-agent strings, or commands.

**Step 3: IOC Extraction & Threat Intelligence Enrichment**
1.  **Compile IOC List:** Create a definitive list of all potential IOCs found in Step 2.
2.  **Enrich IOCs:** For each network-related IOC (IP, URL, Domain), use the 'APICallTool' to query the threat intelligence API.
    * **Example:** 'APICallTool(api='ThreatIntelAPI', params={'ioc': 'evil-domain.com'})'
3.  **Process Intelligence:** Analyze the JSON response for each IOC. Note its reputation (e.g., malicious, suspicious, benign), any associated malware families, and first/last seen dates. If an API call fails for an IOC, note that you were unable to retrieve intelligence for it.

**Step 4: Synthesis & Final Report Generation** 
1.  **Correlate Findings:** Synthesize the data from your static analysis (behavioral assessment) with the data from the threat intelligence enrichment. For example, if you found code that downloads a file from a URL, and that URL is flagged as malicious by the API, you can conclude with high confidence that the binary is a downloader for a specific malware family.
2.  **Determine Intent:** Based on all the evidence, determine the malware's primary function (e.g., Ransomware, Spyware, Downloader, C2 Bot, Infostealer).
3.  **Generate Report:** Produce the final report using the specific format defined below. The report must be clear, concise, and grounded *only* in the evidence you have gathered. Do not speculate beyond the available data.

---

**Final Output Format**

Your final output must be a single, well-formatted Markdown report.

'''markdown
# Malware Analysis Report

**File Assembly:** [Insert file Assembly here]

---

### 1. Executive Summary

* **Verdict:** [MALICIOUS / SUSPICIOUS / BENIGN]
* **Malware Family:** [e.g., Ursnif, RedLine Stealer, Unknown] or "N/A"
* **Primary Capability:** [e.g., Information Stealer, Downloader, Ransomware, C2 Communication]
* **Overall Risk:** [CRITICAL / HIGH / MEDIUM / LOW / NONE]

---

### 2. Behavioral Analysis

A static analysis of the binary indicates the following capabilities:

* **Network Communication:** [Describe the observed network behavior. e.g., "The malware attempts to connect to the C2 server at 198.51.100.10 over port 443. It uses functions like 'InternetOpen' and 'HttpSendRequest' to exfiltrate data."]
* **Persistence:** [Describe any persistence mechanisms. e.g., "The binary creates a registry key at 'HKCU%Software%Microsoft%Windows%CurrentVersion%Run' to ensure it executes on system startup."]
* **Defense Evasion:** [Describe any anti-analysis techniques. e.g., "The code includes a call to 'IsDebuggerPresent' to check if it is being run in a debugger."]
* **File System Interaction:** [Describe how it interacts with files. e.g., "The malware writes a log file to 'C:%Users%Public%Documents%log.txt' and attempts to delete files in the user's home directory."]

---

### 3. Indicators of Compromise (IOCs)

The following IOCs were extracted from the binary and correlated with our threat intelligence platform.

| Type   | Indicator                 | Threat Intel Summary                                      |
| :----- | :------------------------ | :-------------------------------------------------------- |
| **IP** | '198.51.100.10'           | **Malicious.** Associated with RedLine Stealer C2 infrastructure. |
| **URL** | 'http://evil-domain.com/p.exe' | **Malicious.** Known distribution point for SmokeLoader. | 
| **Registry Key** | 'HKCU%Software%Windows%mw' | Common persistence key for unknown malware family.          |
| **Mutex** | 'MyUniqueMutex123'        | Not currently associated with any known threat.           |

---

### 4. Conclusion and Summary

What I did to nalyze the malware was:
1. ...
2. ...
3. ...
4. ...
5. ...

My concludion is:
This binary is a **[Malware Type, e.g., Information Stealer]** with a **[Risk Level]** risk profile. It establishes persistence via the registry and communicates with a known malicious C2 server to exfiltrate data. Immediate blocking of the listed network IOCs is recommended.
""",
            tools=[get_disassembled_file, decode_from_asm_listing],
            before_tool_callback=simple_before_tool_modifier
        )